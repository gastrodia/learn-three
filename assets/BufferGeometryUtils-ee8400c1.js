import{v as y,aH as B,aI as T,aJ as b,aK as E}from"./three.module-b52a2031.js";function A(t,l=!1){const o=t[0].index!==null,m=new Set(Object.keys(t[0].attributes)),u=new Set(Object.keys(t[0].morphAttributes)),a={},e={},f=t[0].morphTargetsRelative,n=new y;let h=0;for(let r=0;r<t.length;++r){const s=t[r];let c=0;if(o!==(s.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const i in s.attributes){if(!m.has(i))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+'. All geometries must have compatible attributes; make sure "'+i+'" attribute exists among all geometries, or in none of them.'),null;a[i]===void 0&&(a[i]=[]),a[i].push(s.attributes[i]),c++}if(c!==m.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". Make sure all geometries have the same number of attributes."),null;if(f!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const i in s.morphAttributes){if(!u.has(i))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+".  .morphAttributes must be consistent throughout all geometries."),null;e[i]===void 0&&(e[i]=[]),e[i].push(s.morphAttributes[i])}if(l){let i;if(o)i=s.index.count;else if(s.attributes.position!==void 0)i=s.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+r+". The geometry must have either an index or a position attribute"),null;n.addGroup(h,i,r),h+=i}}if(o){let r=0;const s=[];for(let c=0;c<t.length;++c){const i=t[c].index;for(let d=0;d<i.count;++d)s.push(i.getX(d)+r);r+=t[c].attributes.position.count}n.setIndex(s)}for(const r in a){const s=p(a[r]);if(!s)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+r+" attribute."),null;n.setAttribute(r,s)}for(const r in e){const s=e[r][0].length;if(s===0)break;n.morphAttributes=n.morphAttributes||{},n.morphAttributes[r]=[];for(let c=0;c<s;++c){const i=[];for(let g=0;g<e[r].length;++g)i.push(e[r][g][c]);const d=p(i);if(!d)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+r+" morphAttribute."),null;n.morphAttributes[r].push(d)}}return n}function p(t){let l,o,m,u=0;for(let f=0;f<t.length;++f){const n=t[f];if(n.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(l===void 0&&(l=n.array.constructor),l!==n.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(o===void 0&&(o=n.itemSize),o!==n.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(m===void 0&&(m=n.normalized),m!==n.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;u+=n.array.length}const a=new l(u);let e=0;for(let f=0;f<t.length;++f)a.set(t[f].array,e),e+=t[f].array.length;return new B(a,o,m)}function x(t,l){if(l===T)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(l===b||l===E){let o=t.getIndex();if(o===null){const e=[],f=t.getAttribute("position");if(f!==void 0){for(let n=0;n<f.count;n++)e.push(n);t.setIndex(e),o=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const m=o.count-2,u=[];if(l===b)for(let e=1;e<=m;e++)u.push(o.getX(0)),u.push(o.getX(e)),u.push(o.getX(e+1));else for(let e=0;e<m;e++)e%2===0?(u.push(o.getX(e)),u.push(o.getX(e+1)),u.push(o.getX(e+2))):(u.push(o.getX(e+2)),u.push(o.getX(e+1)),u.push(o.getX(e)));u.length/3!==m&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=t.clone();return a.setIndex(u),a.clearGroups(),a}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",l),t}export{A as m,x as t};
