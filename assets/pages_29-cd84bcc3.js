import"../d-__uno-a35406a8.js";import{V as g,ai as z,aj as D,ak as W,v as B,w as C,S as q,b as O,c as R,A as _,f as U,M as L,g as J,a as k,W as K}from"../d-three.module-b52a2031.js";import{O as Q}from"../d-OrbitControls-bc3a0338.js";import{i as X}from"../d-dat.gui.module-dd30c9f2.js";const M=0,Y=1,Z=new g,A=new z,P=new D,H=new g,T=new W;class ${constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new S,this.unassigned=new S,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new tt(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(n){const i=n.geometry;if(i!==void 0){const s=i.attributes.position;if(s!==void 0)for(let l=0,o=s.count;l<o;l++){const c=new g;c.fromBufferAttribute(s,l).applyMatrix4(n.matrixWorld),e.push(c)}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,i=e.length;n<i;n++)if(e[n].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const n=this.faces;let i=-1/0,s=1/0;for(let l=0,o=n.length;l<o;l++){const c=n[l],r=c.distanceToPoint(t.origin),u=c.normal.dot(t.direction);if(r>0&&u>=0)return null;const d=u!==0?-r/u:0;if(!(d<=0)&&(u>0?s=Math.min(d,s):i=Math.max(d,i),i>s))return null}return i!==-1/0?t.at(i,e):t.at(s,e),e}intersectsRay(t){return this.intersectRay(t,Z)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(t.outside!==null){const e=t.outside;let n=t.outside;for(;n.next!==null&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(n!==void 0)if(e===void 0)this.unassigned.appendChain(n);else{let i=n;do{const s=i.next;e.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,e):this.unassigned.append(i),i=s}while(i!==null)}return this}resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{const n=e.next;let i=this.tolerance,s=null;for(let l=0;l<t.length;l++){const o=t[l];if(o.mark===M){const c=o.distanceToPoint(e.point);if(c>i&&(i=c,s=o),i>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(e,s),e=n}while(e!==null)}return this}computeExtremes(){const t=new g,e=new g,n=[],i=[];for(let s=0;s<3;s++)n[s]=i[s]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let s=0,l=this.vertices.length;s<l;s++){const o=this.vertices[s],c=o.point;for(let r=0;r<3;r++)c.getComponent(r)<t.getComponent(r)&&(t.setComponent(r,c.getComponent(r)),n[r]=o);for(let r=0;r<3;r++)c.getComponent(r)>e.getComponent(r)&&(e.setComponent(r,c.getComponent(r)),i[r]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,i=e.max;let s=0,l=0;for(let a=0;a<3;a++){const p=i[a].point.getComponent(a)-n[a].point.getComponent(a);p>s&&(s=p,l=a)}const o=n[l],c=i[l];let r,u;s=0,A.set(o.point,c.point);for(let a=0,p=this.vertices.length;a<p;a++){const h=t[a];if(h!==o&&h!==c){A.closestPointToPoint(h.point,!0,H);const m=H.distanceToSquared(h.point);m>s&&(s=m,r=h)}}s=-1,P.setFromCoplanarPoints(o.point,c.point,r.point);for(let a=0,p=this.vertices.length;a<p;a++){const h=t[a];if(h!==o&&h!==c&&h!==r){const m=Math.abs(P.distanceToPoint(h.point));m>s&&(s=m,u=h)}}const d=[];if(P.distanceToPoint(u.point)<0){d.push(f.create(o,c,r),f.create(u,c,o),f.create(u,r,c),f.create(u,o,r));for(let a=0;a<3;a++){const p=(a+1)%3;d[a+1].getEdge(2).setTwin(d[0].getEdge(p)),d[a+1].getEdge(1).setTwin(d[p+1].getEdge(0))}}else{d.push(f.create(o,r,c),f.create(u,o,c),f.create(u,c,r),f.create(u,r,o));for(let a=0;a<3;a++){const p=(a+1)%3;d[a+1].getEdge(2).setTwin(d[0].getEdge((3-a)%3)),d[a+1].getEdge(0).setTwin(d[p+1].getEdge(1))}}for(let a=0;a<4;a++)this.faces.push(d[a]);for(let a=0,p=t.length;a<p;a++){const h=t[a];if(h!==o&&h!==c&&h!==r&&h!==u){s=this.tolerance;let m=null;for(let F=0;F<4;F++){const b=this.faces[F].distanceToPoint(h.point);b>s&&(s=b,m=this.faces[F])}m!==null&&this.addVertexToFace(h,m)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const n=this.faces[e];n.mark===M&&t.push(n)}return this.faces=t,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0;const n=this.assigned.first().face;let i=n.outside;do{const s=n.distanceToPoint(i.point);s>e&&(e=s,t=i),i=i.next}while(i!==null&&i.face===n);return t}}computeHorizon(t,e,n,i){this.deleteFaceVertices(n),n.mark=Y;let s;e===null?s=e=n.getEdge(0):s=e.next;do{const l=s.twin,o=l.face;o.mark===M&&(o.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,l,o,i):i.push(s)),s=s.next}while(s!==e);return this}addAdjoiningFace(t,e){const n=f.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,i=null;for(let s=0;s<e.length;s++){const l=e[s],o=this.addAdjoiningFace(t,l);n===null?n=o:o.next.setTwin(i),this.newFaces.push(o.face),i=o}return n.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();(t=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class f{constructor(){this.normal=new g,this.midpoint=new g,this.area=0,this.constant=0,this.outside=null,this.mark=M,this.edge=null}static create(t,e,n){const i=new f,s=new y(t,i),l=new y(e,i),o=new y(n,i);return s.next=o.prev=l,l.next=s.prev=o,o.next=l.prev=s,i.edge=s,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return T.set(t.point,e.point,n.point),T.getNormal(this.normal),T.getMidpoint(this.midpoint),this.area=T.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class y{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class tt{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class S{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}}class et extends B{constructor(t=[]){super();const e=[],n=[],s=new $().setFromPoints(t).faces;for(let l=0;l<s.length;l++){const o=s[l];let c=o.edge;do{const r=c.head().point;e.push(r.x,r.y,r.z),n.push(o.normal.x,o.normal.y,o.normal.z),c=c.next}while(c!==o.edge)}this.setAttribute("position",new C(e,3)),this.setAttribute("normal",new C(n,3))}}new X.GUI;const{innerWidth:I,innerHeight:j}=window,w=new q,E=new O(45,I/j,.1,1e3);E.position.set(50,50,100);E.lookAt(w.position);const nt=new R(100);w.add(nt);const st=new _(6710886);w.add(st);const V=new U(16777215);V.castShadow=!0;V.position.set(-50,80,50);w.add(V);const G=[],it=new L({color:16711680});for(let x=0;x<20;x++){const t=new g(Math.round(Math.random()*30)+10,Math.round(Math.random()*30)+10,Math.round(Math.random()*30)+10),e=new J(.2),n=new k(e,it);n.position.copy(t),G.push(t),w.add(n)}const ot=new et(G),at=new L({color:65280,wireframe:!0}),rt=new k(ot,at);w.add(rt);const v=new K({antialias:!0});v.setSize(I,j);v.shadowMap.enabled=!0;document.body.appendChild(v.domElement);new Q(E,v.domElement);const N=()=>{requestAnimationFrame(N),v.render(w,E)};N();
